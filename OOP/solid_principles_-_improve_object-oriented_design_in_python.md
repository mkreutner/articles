# SOLID Principles: Improve Object-Oriented Design in Python

## Table of Contents

* [X] [Object-Oriented Design in Python: The SOLID Principles](./object-oriented_design_in_python_-_the_solid_principles.md)
* [ ] [Single-Responsibility Principle (SRP)](./single-responsibility_principle.md)
* [ ] [Open-Closed Principle (OCP)](./open-closed_principle.md)
* [ ] [Liskov Substitution Principle (LSP)](./liskov_substitution_principle.md)
* [ ] [Interface Segregation Principle (ISP)](./interface_segregation_principle.md)
* [ ] [Dependency Inversion Principle (DIP)](./dependency_inversion_principle.md)
* [ ] [Conclusion](./conclusion.md)

Lorsque vous développez un projet Python en **programmation orientée objet** (OOP), 
planifier l'interaction des différentes classes et objets pour résoudre vos 
problèmes spécifiques est une étape importante. Cette planification est 
appelée **conception orientée objet** (OOD), et la réussir peut s'avérer 
complexe. Si vous rencontrez des difficultés lors de la conception de vos 
classes Python, les principes **SOLID** peuvent vous aider.

SOLID est un ensemble de cinq principes de conception orientée objet qui vous 
aident à écrire du code plus maintenable, flexible et évolutif, basé sur des 
classes bien conçues et clairement structurées. Ces principes constituent 
un élément fondamental des bonnes pratiques de conception orientée objet.

**Dans ce tutoriel, vous allez :**

* Comprendre la **signification** et l'**objectif** de chaque **principe SOLID** ;
* Identifier le code Python qui **enfreint** certains principes SOLID ;
* Appliquer les principes SOLID pour **refactoriser** votre code Python et 
  améliorer sa conception.

Tout au long de votre parcours d'apprentissage, vous coderez des exemples 
pratiques pour découvrir comment les principes SOLID peuvent conduire à un 
code bien organisé, flexible, maintenable et évolutif.

Pour tirer le meilleur parti de ce didacticiel, vous devez avoir une bonne 
compréhension des concepts de programmation orientée objet Python, tels 
que les classes, les interfaces et l'héritage.